## Вопрос 1:

Ответил на вопрос правильно, подробно и доступно описал проблему.

Предложил решения:
 - Вынести расчёт в Web Worker
 - Разбить задачи на части (Chunking / Yielding to Main Thread):
   0. разбить задачу на более мелкие сегменты
   1. использовать setTimeout между сегментами
   2. scheduler.yield() - (экспериментальный API): Более современный API для уступки контроля основному потоку
 - Отложенное выполнение с помощью requestIdleCallback
 - Оптимизация самого вычисления (дал пример как можно оптимизировать)
 - 
Краткий вывод:
"Избегайте длительных синхронных операций в основном потоке. Используйте Web Workers для вычислений, не требующих прямого доступа к DOM, или разбивайте задачи, чтобы поддерживать отзывчивость интерфейса"

## Вопрос 2:
- Рабочий код за 4 промпта

## Вопрос 3:
#### Уточнения к заданию
- Time to Interactive(TTI) заменил на Interaction to Next Paint (INP), тк TTI теперь deprecated и удалена из Lighthouse;
- FCP и LCP первое значение из Perfomanse, второе значение из Lighthouse. 180ms - это среднее арифметическое из 4 замеров;

#### Результаты:
- FCP: 180ms; 0.9s
- LCP: 180ms; 1.5s
- TBT: 60ms 
- INP: 10ms
